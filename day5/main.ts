export function validateManualsUpdates(input: string): {
  results: {
    pages: number[];
    isValid: boolean;
  }[];
  rules: {
    before: number;
    after: number;
  }[];
} {
  const [rulesInput, manualsUpdatesInput] = input.trim().split("\n\n");

  // Parse rules
  const rules = rulesInput.split("\n").map((line) => {
    const [a, b] = line.split("|").map(Number);
    return { before: a, after: b };
  });

  // Parse manuals
  const manualsUpdate = manualsUpdatesInput.split("\n").map((line) =>
    line.split(",").map(Number)
  );

  return {
    results: manualsUpdate.map((updatePages) => ({
      pages: updatePages,
      isValid: validateList(updatePages, rules),
    })),
    rules: rules,
  };
}

export function calculateMiddleValueValid(list: {
  pages: number[];
  isValid: boolean;
}[]): number {
  return list
    .filter((result) => result.isValid) // Only valid lines
    .map((result) => result.pages[Math.floor(result.pages.length / 2)]) // Extract the middle number
    .reduce((sum, num) => sum + num, 0);
}

export function sortAndCalculateMiddleValueInvalid(input: {
  results: {
    pages: number[];
    isValid: boolean;
  }[];
  rules: {
    before: number;
    after: number;
  }[];
}): number {
  return input.results.filter((result) => !result.isValid)
    .map((result) => {
        const orderedList = orderList(result.pages, input.rules);
        return orderedList[Math.floor(orderedList.length / 2)];
    })
    .reduce((sum, num) => sum + num, 0);
}

function validateList(
  list: number[],
  rules: { before: number; after: number }[],
): boolean {
  const positionMap = new Map<number, number>();
  list.forEach((value, index) => positionMap.set(value, index));

  for (const rule of rules) {
    const posBefore = positionMap.get(rule.before);
    const posAfter = positionMap.get(rule.after);

    if (posBefore === undefined || posAfter === undefined) {
      continue;
    }
    if (posBefore > posAfter) {
      return false;
    }
  }

  return true;
}

// Function to order a list using topological sorting
// generated by ChatGPT
function orderList(
  list: number[],
  rules: { before: number; after: number }[],
): number[] {
  // Build adjacency list and in-degree count
  const adjacencyList = new Map<number, number[]>();
  const inDegree = new Map<number, number>();

  // Initialize in-degree and adjacency list for all numbers in the list
  list.forEach((num) => {
    adjacencyList.set(num, []);
    inDegree.set(num, 0);
  });

  // Populate adjacency list and in-degree based on rules
  rules.forEach(({ before, after }) => {
    if (!adjacencyList.has(before) || !adjacencyList.has(after)) return; // Ignore rules with numbers not in the list
    adjacencyList.get(before)?.push(after);
    inDegree.set(after, (inDegree.get(after) || 0) + 1);
  });

  // Topological sort using Kahn's algorithm
  const queue: number[] = [];
  inDegree.forEach((degree, num) => {
    if (degree === 0) queue.push(num);
  });

  const sortedList: number[] = [];
  while (queue.length > 0) {
    const current = queue.shift()!;
    sortedList.push(current);

    adjacencyList.get(current)?.forEach((neighbor) => {
      inDegree.set(neighbor, inDegree.get(neighbor)! - 1);
      if (inDegree.get(neighbor) === 0) queue.push(neighbor);
    });
  }

  // If the sorted list doesn't contain all numbers, there was a cycle (invalid input).
  if (sortedList.length !== list.length) {
    throw new Error("Cannot order list due to cyclic dependencies.");
  }

  return sortedList;
}

if (import.meta.main) {
  const text = await Deno.readTextFile("input.txt");
  const validatedList = validateManualsUpdates(text);
  console.log("Sum valid:", calculateMiddleValueValid(validatedList.results));
  console.log(
    "Sum invalid sorted:",
    sortAndCalculateMiddleValueInvalid(validatedList),
  );
}
